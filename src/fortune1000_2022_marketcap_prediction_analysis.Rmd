---
title: "R Analysis of the 2022 Fortune 1000 for Market Cap Prediction"
author: "Stefanus Bernard Melkisedek"
date: "2024-03-07"
output: 
    prettydoc::html_pretty:
        theme: cayman
        highlight: github
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, fig.path = "../figures/")
```

## Introduction

Fortune, an American Business Magazine, annually publishes the Fortune
500, a ranking of the top 500 firms based on their income. **This
dataset comprises the complete Fortune 1000, rather than solely the top
500**.

**The objective of this capstone project is** to analyze the 2022
Fortune 1000 firms in order **to make predictions regarding their market
value**. The dataset is sourced from the Kaggle website: [2022 Fortune
1000](https://www.kaggle.com/datasets/winston56/fortune-500-data-2021/data).
The **dataset provides updated U.S. firm data for the year 2022**,
replacing the previous data from 2021.

## load the libraries

The following libraries will be used in this analysis:

```{r load-packages, message=FALSE, warning=FALSE}
# tidyverse: Collection of packages for data manipulation and visualization
library(tidyverse)

# knitr: Enables dynamic report generation
library(knitr)

# kableExtra: Helps build common complex tables and manipulate table styles
library(kableExtra)

# janitor: Provides simple tools for examining and cleaning dirty data
library(janitor)

# skimr: Provides summary statistics for data exploration
library(skimr)

# broom: Converts statistical analysis objects into tidy format
library(broom)

# car: Companion to Applied Regression, provides tools for regression analysis
library(car)

# MASS: Support functions and datasets for Venables and Ripley's MASS
library(MASS)

# modelr: Provides functions for modelling that help with data tidying
library(modelr)
```

## Business Questions

The following are the business questions that will be addressed in this
analysis:

```{r table-business-question, echo=FALSE}
# Define the business questions
business_questions <- data.frame(
  'No.' = c(1, 2, 3),
  'Business_Question' = c(
    'How can we accurately predict the market cap of companies entering the Fortune 1000 list for the first time (Newcomer="yes") based on the available data from the previous year (2022)?',
    'How can we predict the future market cap of companies already present on the 2022 Fortune 1000 list (Newcomer="no") by analyzing the changes in their financial metrics like revenue, profit, and number of employees, along with other factors like rank change, CEO demographics, and sector?',
    'What are the key factors (financial, company-related, or others) that have the most significant influence on the market cap of companies within different sectors present in the Fortune 1000 list?'
  )
)

# Create the table
business_questions %>%
  kable("html") %>%
  kable_styling(bootstrap_options = "striped", full_width = F) %>%
  column_spec(1, bold = TRUE) %>%
  column_spec(2, bold = TRUE) %>%
  row_spec(0, align = "c", bold = TRUE)
```

## Data Wrangling

### Gathering the Data

The dataset is loaded from the CSV file and stored in a dataframe called
`fortune_df`.

```{r load-data, echo=TRUE}
# Load the dataset
fortune_df <- read_csv("../data/Fortune_1000.csv")
```

### Assessing the Data

The following steps are taken to assess the dataset:

1.  **Data Structure**: The structure of the dataset is examined to
    understand the number of rows and columns, as well as the data types
    of the columns.

```{r head-fortune-df, echo=TRUE}
# Display the first six rows of the dataset
head(fortune_df)
```

```{r data-structure, echo=TRUE}
# Display the structure of the dataset
str(fortune_df)
```

As we can see from the data structures, this **dataset contains 1000
rows and 18 columns**, with a mix of numerical and categorical data
types.

**Based on the data types of the columns**, there is one column that
needs to be converted to a double data type. The `Market Cap` column is
**currently a character data type**, but **it should be a double data
type**.

2.  **Summary Statistics**: The summary statistics of the dataset are
    examined to understand the distribution of the data.

```{r summary-statistics, echo=TRUE}
# Display the summary statistics of the dataset
skim_without_charts(fortune_df)
```

3.  **Missing Values**: The presence of missing values in the dataset is
    checked.

The summary data table shows that there are **Two column that have
missing values** in the data type character and there are **Three
columns that have missing values** from the data type numeric.

The columns from data type character with missing values are: -
`Ticker`: 49 missing value - `Market Cap`: 1 missing value

`Ticker` **is the unique symbol of publicly traded** companies, so it is
not a problem if there are **missing values in the ticker column, it
means that company is a private company**. But, the `Market Cap` column
is important for the analysis, so the missing value in this column needs
to be handled.

The columns from data type numeric with missing values are: - `profit`:
3 missing value - `num. of employees`: 1 missing value - `prev_rank`:
531 missing value

`prev_rank` indicates the previous rank of the company, so it is not a
problem if there are **missing values in the prev_rank column, it means
that company is not listed in the top 500 companies last year**. But,
the `profit` and `num. of employees` columns are important for the
analysis, so the missing value in these columns needs to be handled.

4.  **Duplicate Rows**: The presence of duplicate rows in the dataset is
    checked.

To see the duplicate rows in the dataset, the `duplicated()` function is
used to check for duplicate rows. The result shows that there are no
duplicate rows in the dataset.

```{r duplicate-rows, echo=TRUE}
# Check for duplicate rows
fortune_df[duplicated(fortune_df), ]

# Count the number of duplicate rows and save it to a variable
duplicate_rows <- fortune_df[duplicated(fortune_df), ] %>% nrow()

# Display the number of duplicate rows
print(glue::glue("The number of duplicate rows in the dataset is {duplicate_rows}."))
```

**There are no duplicate rows** in the dataset, so let's move on to the
next step.

5.  **Column Names**: The column names are examined to ensure they are
    consistent and easy to work with.

The column names are not consistent and contain spaces and special
characters. The column names with these criteria are as follows: -
`num. of employees` - `CEO` - `Website` - `Ticker` - `Market Cap`

6.  **Unique Values**: The unique values of the categorical columns are
    examined to understand the different categories present in the
    dataset.

To check the unique values of the categorical columns, the `unique()`
function is used to display the unique values of the `Sector` and
`Industry` columns.

```{r sector-unique-values, echo=TRUE}
# Display the unique values of the Sector Industry columns
unique_sector <- fortune_df %>% 
  distinct(sector)

unique_sector %>% kable()
```

```{r city-unique-values, echo=TRUE}
# Display the unique values of the City column
# unique_city <- fortune_df %>% 
#   distinct(city)
# 
# unique_city %>% kable()
```

```{r state-unique-values, echo=TRUE}
# Display the unique values of the State column
unique_state <- fortune_df %>% 
  distinct(state)

unique_state %>% kable()
```

7.  **Outliers**: The presence of outliers in the numerical columns is
    checked.

To check for outliers in the numerical columns, the `boxplot()` function
is used to create boxplots for the `revenue`, `profit`, and
`num. of employees` columns.

```{r boxplot-revenue, echo=TRUE}
# Create a boxplot for the revenue column
ggplot(data = fortune_df) +
  geom_boxplot(mapping = aes(x = revenue), colour = "#15925e") +
  labs(title = "Boxplot of Revenue") +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  )
```

```{r boxplot-profit, echo=TRUE}
# Create a boxplot for the profit column
ggplot(data = fortune_df) + 
  geom_boxplot(mapping = aes(x = profit), colour = "#15925e") +
  labs(title = "Boxplot of Profit") +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  )
```

From the `profit` and revenue `boxplot`, we could conclude that there
are some company with a very high revenue and profit. But, it is not an
outlier, because it is a common thing in the business world. So, we
could conclude that there are no outliers in the revenue and profit
columns.

8.  **Data Quality**: The overall quality of the dataset is assessed.

The assessment of the dataset is summarized in the table below:

**Table of Summary Assessment**

```{r summary-assessment, echo=TRUE}
# Check for missing values
missing_values <- vapply(fortune_df, function(x) sum(is.na(x)), FUN.VALUE = numeric(1))

# Check for duplicate rows
duplicate_rows <- anyDuplicated(fortune_df)

# Get data types
data_types <- vapply(fortune_df, function(x) class(x)[1], FUN.VALUE = character(1))

# Combine all into a data frame
assessment_df <- data.frame(
  MissingValues = missing_values,
  DuplicateRows = duplicate_rows,
  DataTypes = data_types
)

# Show the assessment table
assessment_df %>% kable()
```

### Cleaning the Data

The following steps are taken to clean the dataset:

1.  **Handling the column names**

```{r column-names, echo=TRUE}
# Clean the column names with janitor
fortune_df <- fortune_df %>% 
  clean_names()

# Check the cleaned column names
colnames(fortune_df)
```

2.  **Handling the data types**

```{r data-types, echo=TRUE}
# Convert the Market Cap column to a double data type
fortune_df <- fortune_df %>% 
  mutate(market_cap = as.numeric(market_cap))

# Check if the data type of the Market Cap column has been converted
data_type_market_cap <- class(fortune_df$market_cap)
glue::glue("The data type of the Market Cap column is {data_type_market_cap}.")
```

3.  **Handling the missing value**

```{r missing-value-profit, echo=TRUE}
# View the records with missing values in the profit feature
fortune_df %>% 
  filter(is.na(profit)) %>% 
  kable()

# Fill the missing values in the profit column with the median value
fortune_df <- fortune_df %>% 
  mutate(profit = ifelse(is.na(profit), median(profit, na.rm = TRUE), profit))

# Check if the missing values in the profit column have been handled
missing_values_profit <- sum(is.na(fortune_df$profit))
glue::glue("The number of missing values in the profit column is {missing_values_profit}.")
```

```{r missing-value-employees, echo=TRUE}
# View the records with missing values in the num_of_employees feature
fortune_df %>% 
  filter(is.na(num_of_employees)) %>%
  kable()
```

As we can see, there is no ticker(stock ticker symbol) in the
`Univision Communications` company that tells this is a private company,
so we could fill the missing value in the `num_of_employees` column with
0

```{r fill-missing-value-employees, echo=TRUE}
# Fill the missing values in the num_of_employees column with 0
fortune_df <- fortune_df %>% 
  mutate(num_of_employees = ifelse(is.na(num_of_employees), 0, num_of_employees))

# Check if the missing values in the num_of_employees column have been handled
missing_values_employees <- sum(is.na(fortune_df$num_of_employees))
glue::glue("The number of missing values in the num_of_employees column is {missing_values_employees}.")
```

```{r missing-value-ticker, echo=TRUE}
# Check the missing values in the Ticker feature
missing_values_ticker <- fortune_df %>% 
  filter(is.na(ticker)) %>%
  nrow()

glue::glue("The number of missing values in the Ticker column is {missing_values_ticker}.")
```

```{r fill-missing-value-ticker, echo=TRUE}
# Fill the missing values in the Ticker column with "Private"
fortune_df <- fortune_df %>% 
  mutate(ticker = ifelse(is.na(ticker), "Private", ticker))

# Check if the missing values in the Ticker column have been handled
missing_values_ticker <- sum(is.na(fortune_df$ticker))
glue::glue("The number of missing values in the Ticker column is {missing_values_ticker}.")
```

```{r missing-value-prev-rank, echo=TRUE}
# Check again the number of missing values in the prev_rank column
missing_values_prev_rank <- fortune_df %>% 
  filter(is.na(prev_rank)) %>%
  nrow()

glue::glue("The number of missing values in the prev_rank column is {missing_values_prev_rank}.")
```

```{r fill-missing-value-prev-rank, echo=TRUE}
# Fill the missing values in the prev_rank column with 0
fortune_df <- fortune_df %>% 
  mutate(prev_rank = ifelse(is.na(prev_rank), 0, prev_rank))

# Check if the missing values in the prev_rank column have been handled
missing_values_prev_rank <- sum(is.na(fortune_df$prev_rank))
glue::glue("The number of missing values in the prev_rank column is {missing_values_prev_rank}.")
```

```{r missing-value-market-cap, echo=TRUE}
# View the records with missing values in the Market Cap feature
fortune_df %>% 
  filter(is.na(market_cap)) %>% 
  kable()
```

```{r fill-missing-value-market-cap, echo=TRUE}
# Fill the missing values in the Market Cap using median value
fortune_df <- fortune_df %>% 
  mutate(market_cap = ifelse(is.na(market_cap),
  median(market_cap, na.rm = TRUE), market_cap))

# Check if the missing values in the Market Cap column have been handled
missing_values_market_cap <- sum(is.na(fortune_df$market_cap))
glue::glue("The number of missing values in the Market Cap column is {missing_values_market_cap}.")
```

Now, let's check again for the overall missing values using the skimr
package.

```{r missing-values-overall, echo=TRUE}
# Display the summary statistics of the dataset
skim_without_charts(fortune_df)
```

Since the unique values of the ceo feature is 994, It seems that there
are duplicate values in the ceo feature. Let's check for the duplicate
values in the ceo feature.

```{r duplicate-values-ceo, echo=TRUE}
# Check for duplicate values in the ceo feature
duplicate_ceo <- fortune_df %>% 
  group_by(ceo) %>% 
  summarize(n = n()) %>%
  filter(n > 1)

# Display the duplicate values in the ceo feature
duplicate_ceo %>% kable()
```

From the table above, we could see that `Elon Musk` and
`Vincent T. Roche` are the CEO of two companies.

Let's check it out first what companies are they leading.

```{r check-ceo-companies, echo=TRUE}
# Check the companies that Elon Musk and Vincent T. Roche are leading
fortune_df %>% 
  dplyr::filter(ceo == "Elon Musk" | ceo == "Vincent T. Roche") %>%
  dplyr::select(company, ceo) %>% 
  kable()
```

So, it is not a duplicate value, it is a common thing in the business
world.

Next, we would like to check the ceo with name `#REF`. Let's check it
out first what company is he leading.

```{r check-ceo-ref, echo=TRUE}
# Check the company that the CEO with name #REF is leading
fortune_df %>% 
  dplyr::select(company, ceo) %>% 
  dplyr::filter(ceo == "#REF!") %>%
  kable()
```

It seems there are companies with the CEO named `#REF!`, this would be
causing by the The `#REF!` error typically **appears when a reference is
not valid**. This is common in spreadsheet software like Excel, where it
can occur if a formula refers to a cell that doesn't exist, usually
because the cell's row or column has been deleted.

```{r fill-missing-value-ceo, echo=TRUE}
# Fill the missing values in the ceo column with "Unknown"
fortune_df <- fortune_df %>% 
  mutate(ceo = ifelse(ceo == "#REF!", "Unknown", ceo))

# Check if the invalid values in the ceo column have been handled
invalid_values_ceo <- sum(fortune_df$ceo == "#REF!")
glue::glue("The number of invalid values in the ceo column is {invalid_values_ceo}.")
```

```{r list-of-numeric-columns, echo=TRUE}
# List of numeric columns
numeric_columns <- fortune_df %>% 
  dplyr::select(where(is.numeric)) %>% 
  colnames()

# View the column names of the numeric columns
numeric_columns
```

For the final step, let's check the distribution of the columns
`revenue`, `profit`, `num_of_employees`, and `market_cap` using the
`ggplot2` packages.

```{r distribution-revenue, echo=TRUE}
# Create a histogram for the revenue column
ggplot(data = fortune_df, aes(x = revenue)) +
  geom_histogram(fill = "#15925e", color = "black") +
  labs(
    title = "Distribution of Revenue (Log Scale)",
    x = "Revenue"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(label = scales::dollar)
```

The `scale_x_log10()` function transforms the x-axis using a logarithmic
scale, which can be **useful when dealing with data that spans several
orders of magnitude**.

**In a logarithmic scale**, the **distance from 1 to 10 is the same as
the distance from 10 to 100**, or from 100 to 1000, and so on. This is
because each step on the scale is a multiplication by 10, rather than an
addition.

```{r distribution-profit, echo=TRUE}
# Create a histogram for the profit column
ggplot(data = fortune_df) +
  geom_histogram(mapping = aes(x = profit), fill = "#15925e", color = "black") +
  labs(
    title = "Distribution of Profit (Log Scale)",
    x = "Profit"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(labels = scales::dollar)
```

```{r distribution-market-cap, echo=TRUE}
# Create a histogram for the market_cap column
ggplot(data = fortune_df) +
  geom_histogram(mapping = aes(x = market_cap), fill = "#15925e", color = "black") +
  labs(
    title = "Distribution of Market Cap (Log Scale)",
    x = "Market Cap"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(label = scales::dollar)
```

```{r distribution-employees, echo=TRUE}
# Create a histogram for the num_of_employees column
ggplot(data = fortune_df) +
  geom_histogram(mapping = aes(x = num_of_employees), fill = "#15925e", color = "black") +
  labs(
    title = "Distribution of Number of Employees (Log Scale)",
    x = "Number of Employees"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(label = scales::comma)
```

As we can see on the distribution of `revenue` there is a **left-skewed
distribution**, it means that there are some companies with a very high
revenue. The distribution of `profit` and `market_cap` also have a
**left-skewed distribution**, it means that there are some companies
with a very high profit and market cap.

The distribution of `num_of_employees` have a **left-skewed
distribution**, it means that there are some companies with a very high
number of employees.

**Conclusion:**

-   The column names have been cleaned and are now consistent and easy
    to work with.

-   The `Market Cap` column has been converted to a **double data
    type**.

-   The missing values in the `profit`, `num_of_employees`, `ticker`,
    `prev_rank`, and `market_cap` columns have been **handled**.

-   The invalid values in the `ceo` column has been handled by filling
    the missing values with "Unknown".

**Additional Note for the outlier in the `revenue`, `market_cap` and
`profit` columns:**

-   The outlier in the `revenue`, `market_cap` and `profit` columns are
    not handled because it is a common thing in the business world.

## Exploratory Data Analysis

list of interesting questions to be answered in the exploratory data
analysis:

**1. Predicting Market Cap of New Entrants (Newcomer="yes")**

-   **Univariate Analysis**:

    • **Question**: How is the market cap of existing companies
    (Newcomer="no") distributed? Are there any outliers that might
    require further investigation?

    • **Question**: How do features like revenue, profit, and number of
    employees for companies entering the list for the first time
    (Newcomer="yes") compare to existing companies in terms of
    distribution?

    • **Question**: What does the distribution of rank change look like
    for companies that entered the list (Newcomer="yes")?

-   **Bivariate Analysis**:

    • **Question**: Is there a visual relationship between market cap
    and features like revenue, profit, and number of employees for
    established companies (Newcomer="no")?

    • **Question**: How does the rank change of new entrants relate to
    their market cap?

    • **Question**: Do these relationships between market cap and other
    features differ across various sectors? (Use boxplots or violin
    plots to compare market cap distribution)

-   **Multivariate Analysis**:

    • **Question**: Can we build a machine learning model that
    accurately predicts the market cap of new entrants (Newcomer="yes")
    based on all available features (excluding Market Cap)?

    • **Question**: How well does this model perform in predicting
    market cap? Evaluate the model's accuracy using relevant metrics
    like R-squared or mean squared error.

**2. Predicting Market Cap of Existing Companies (Newcomer="no")**

-   **Univariate Analysis**:

    • **Question**: How have the market caps of existing companies
    changed between 2021 and 2022? What is the distribution of those
    changes?

    • **Question**: How have financial metrics like revenue, profit, and
    number of employees changed for existing companies between 2021 and
    2022? Explore the distribution of these changes.

-   **Bivariate Analysis**:

    • **Question**: Is there a relationship between the change in market
    cap and the changes in features like revenue, profit, and number of
    employees for existing companies?

    • **Question**: How does the rank change of existing companies
    relate to their market cap change?

-   **Multivariate Analysis**:

    • **Question**: Can we build a regression model to predict the
    market cap change for existing companies based on changes in
    financial metrics and other relevant features (rank change, sector)?

    • **Question**: How well does this model perform in predicting the
    change in market cap for existing companies? Evaluate the model's
    performance using relevant metrics.

**3. Identifying Key Factors Influencing Market Cap**

-   **Univariate Analysis**:

    • **Question**: How does the market cap of companies differ across
    different sectors based on their distribution?

-   **Bivariate Analysis**:

    • **Question**: Are there significant differences in market cap
    distribution within different sectors? Use boxplots or violin plots
    for comparison.

    • **Question**: Within each sector, is there a relationship between
    market cap and categorical features like CEO demographics (CEO
    founder, CEO woman)?

-   **Multivariate Analysis**:

    • **Question**: Can we build separate regression models for each
    sector to predict market cap using relevant features (financial
    metrics, rank change, sector-specific factors)?

    • **Question**: By comparing the coefficients of these models across
    sectors, can we identify the most influential factors for market cap
    in each sector?

Now let's start jump in with the first question.

### Predicting Market Cap of New Entrants (Newcomer="yes")

#### Univariate Analysis

Question 1: How is the market cap of existing companies (Newcomer="no")
distributed? Are there any outliers that might require further
investigation?

```{r existing-market-cap-distribution, echo=TRUE}
# Create the variable of existing_df for the existing companies
existing_df <- fortune_df %>% 
  filter(newcomer == "no")

# Create a histogram for the market cap of existing companies
ggplot(data = existing_df) +
  geom_histogram(mapping = aes(x = market_cap), fill = "#15925e", color = "black") +
  labs(
    title = "Distribution of Market Cap for Existing Companies (Log Scale)",
    x = "Market Cap"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(label = scales::dollar)
```

```{r existing-market-cap-boxplot, echo=TRUE}
# Create a boxplot for the market cap of existing companies to identify outliers
ggplot(data = existing_df) +
  geom_boxplot(mapping = aes(x = market_cap), fill = "#15925e", color = "black") +
  labs(
    title = "Boxplot of Market Cap for Existing Companies (Log Scale)",
    x = "Market Cap"
  ) +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
  ) +
  scale_x_log10(label = scales::dollar)
```

The distribution of the market cap for existing companies is
**left-skewed**, with a few companies having very high market caps.

Let's see the list of existing companies with the highest market cap.

```{r highest-market-cap-companies, echo=TRUE}
# List of companies with the highest market cap
highest_market_cap_companies <- existing_df %>% 
  arrange(-market_cap) %>% 
  head(10)

highest_market_cap_companies %>% kable()
```

The top 10 of existing companies with the highest market cap are
**Apple, Microsoft, Alphabet, Amazon, Tesla, Berkshire Hathaway,
UnitedHealth Group, Visa, Meta Platforms, and Johnson & Johnson**.

Next, we should check the list of existing companies with the lowest
market cap.

```{r lowest-market-cap-companies, echo=TRUE}
# List of companies with the lowest market cap
lowest_market_cap_companies <- existing_df %>% 
  arrange(market_cap) %>% 
  head(10)

lowest_market_cap_companies %>% kable()
```

The lowest 10 of existing companies with the lowest market cap are
**Cooper-Standard Holdings, NGL Energy Partners, R.R. Donnelley & Sons,
Yellow, Vroom, Hovnanian Enterprises, Quad/Graphics, Party City Holdco,
Olympic Steel, and Sprague Resources**.

**Conclusion:**

Since **the top 10 of existing companies with the highest market cap are
well-known companies**, it is not an outlier. The same thing goes for
the lowest 10 of existing companies with the lowest market cap, it is
not an outlier. **So, there are no outliers that need further
investigation**.
